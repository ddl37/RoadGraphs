"""
Given a .pycgr file generated by [OsmToRoadGraph](https://github.com/AndGem/OsmToRoadGraph) from an exported .osm file from [OpenStreetMaps](https://www.openstreetmap.org/), generate an adjacency list representation of the road graph

```sh
python OsmToRoadGraph/run.py -f ./Auckland.osm -n c
```
The generated .pycgr_names file contains the road names of edges
"""

from disjoint_set import DisjointSet
from itertools import chain, dropwhile, islice as take
from toolz import compose
from collections import defaultdict

import networkx
import json
import time

# rimg.py == OsmToRoadGraph/examples/pycgr-to-png/pycgr-to-png.py
# from rimg import draw_graph, Node, Edge

class IgnoreEdgeComponent(Exception):
    pass


def count(it):
    counts = defaultdict(lambda: 0)
    for i in it:
        counts[i] += 1
    return counts


def start_endpoint(component):
    # horrible, horrible code: tries to deal with directions being inconsistent
    firsts = {e[0] for e in component}
    chain_nodes = list(chain(*component))
    chain_count = count(chain_nodes)
    chain_count_count = count(chain_count.values())
    if not (chain_count_count[1] == 2 and 2 * chain_count_count[2] == len(chain_nodes) - 2):
        assert chain_count_count[1] == 0 and 2 * chain_count_count[2] == len(chain_nodes)
        raise IgnoreEdgeComponent()

    post_yield = []
    for n, c in chain_count.items():
        if c == 1:
            if n in firsts:
                yield n
            else:
                post_yield.append(n)
    yield from post_yield

def filter_edge_map(f, it):
    for i in it:
        try:
            yield f(i)
        except IgnoreEdgeComponent:
            continue

class RoadGraph:
    def __init__(self, nodes, edges, components):
        self.nodes, self.edges, self.components = nodes, edges, components

    def __repr__(self):
        return f"RoadGraph with {len(self.nodes)} vertices and {len(self.edges)} edges"

    @staticmethod
    def from_file(path, reduce_roads=True):
        NODE_METADATA = {}
        EDGE_METADATA = {}
        EDGE_COMPONENTS = DisjointSet()

        with open(path) as f:
            f = dropwhile(lambda x: x[0] == "#", map(compose(str.split, str.strip), f))

            num_nodes = int(next(f)[0])
            num_edges = int(next(f)[0])

            # node id in [0, num_nodes - 1]
            for node_id, lat, long in take(f, num_nodes):
                NODE_METADATA[int(node_id)] = (float(lat), float(long))

            # need two passes
            incident_edges_to = defaultdict(lambda: [])

            for source_id, target_id, length_meters, street_type, max_speed_km, is_bidirectional in take(f, num_edges):
                source_id, target_id = int(source_id), int(target_id)

                if not (street_type in ["motorway", "trunk", "primary", "secondary", "tertiary"] or "link" in street_type) and reduce_roads:
                    continue

                EDGE_COMPONENTS.find((source_id, target_id))

                EDGE_METADATA[(source_id, target_id)] = (float(length_meters), street_type, int(max_speed_km), int(is_bidirectional))

                incident_edges_to[target_id].append((source_id, target_id))
                # if int(is_bidirectional):
                incident_edges_to[source_id].append((source_id, target_id))

        # edges merged into components
        for (source_id, target_id), data in EDGE_METADATA.items():
            # each each should appear exactly once
            assert (target_id, source_id) not in EDGE_METADATA.keys()

            if len(incident_edges_to[source_id]) == 2:
                EDGE_COMPONENTS.union(*incident_edges_to[source_id])

            if len(incident_edges_to[target_id]) == 2:
                EDGE_COMPONENTS.union(*incident_edges_to[target_id])

        return RoadGraph(NODE_METADATA, EDGE_METADATA, list(EDGE_COMPONENTS.itersets()))

    def is_bidirectional(self, edge):
        return bool(self.edges[edge][3])

    def location(self, node) -> (float, float):
        return self.nodes[node]

    def length(self, edge):
        return self.edges[edge][0]

    def flatten_component(self, component: {(int, int)}):
        # used to process edge equivalence classes into new individual edges
        direction = False
        fwd = {}
        back = {}

        for u, v in component:
            fwd[u] = v
            back[v] = u
            direction |= self.is_bidirectional((u, v))

        # theoretically all edges in a component should have the same bidirectionality
        # not generally true because some roads have been excluded, ramps onto motorways...
        # if conflicted, assume bidirectional
        if not all(self.is_bidirectional(e) == direction for e in component):
            # incorrect direction, doesn't really matter
            pass

        path = [next(start_endpoint(component))]
        for _ in range(len(component)):
            path.append(fwd.get(path[-1], back.get(path[-1])))

        return (path[0], path[-1]), self.merge_metadata(path, direction)

    def merge_metadata(self, node_sequence: [int], direction):
        repr_edge = lambda e: e if e in self.edges else tuple(reversed(e))
        original_edges = [repr_edge((node_sequence[i], node_sequence[i + 1])) for i in range(len(node_sequence) - 1)]
        return (sum(map(self.length, original_edges)), *self.edges[original_edges[0]][1:3], int(direction))

    def flatten(self):
        new_edges = dict(filter_edge_map(self.flatten_component, self.components))
        nodes = set(chain(*new_edges.keys()))
        new_nodes = dict(filter(lambda n: n[0] in nodes, self.nodes.items()))
        return RoadGraph(new_nodes, new_edges, None)

    """
    Reassign node ids starting from `offset`
    - 0 for Python, C++, ... users
    - 1 for Julia, Matlab, ... users
    """
    def relabel_contiguous(self, offset):
        node_id_map = dict(map(compose(tuple, reversed), enumerate(self.nodes.keys())))
        return RoadGraph({node_id_map[k] + offset: v for k, v in self.nodes.items()}, {(node_id_map[u] + offset, node_id_map[v] + offset): value for (u, v), value in self.edges.items()}, None)

    def draw(self, name="auckland.png"):
        draw_graph(
            {n: Node(*v) for n, v in self.nodes.items()},
            [Edge(k[0], k[1], 50) for k, v in self.edges.items()],
            2160,
            2160,
            "",
            name
        )

    def adjacency_list(self):
        INCIDENCE: {int, [int]} = defaultdict(lambda: [])

        for u, v in self.edges.keys():
            INCIDENCE[u].append(v)
            if self.is_bidirectional((u, v)):
                INCIDENCE[v].append(u)

        print(len(self.nodes))
        for i in range(OFFSET, len(self.nodes) + OFFSET):
            print(" ".join(map(str, INCIDENCE[i])))

    def networkx_export(self, file):
        G = networkx.DiGraph()

        for n, (lat, long) in self.nodes.items():
            G.add_node(n, latitude=lat, longitude=long)
        
        for (u, v), (length, street_type, max_speed, direction) in self.edges.items():
            G.add_edge(u, v, length = length, street_type = street_type)
            if direction:
                G.add_edge(v, u, length=length, street_type=street_type)

        G_json = networkx.readwrite.node_link_data(G, {"link": "edges", "source": "from", "target": "to"})
        with open(file, "w") as f:
            json.dump(G_json, f)


"""
`in_file` should be the path to your .pycgr file
"""
def export(offset, in_file="Maps/Auckland.pycgr", out_file="graph.json"):
    gr = RoadGraph.from_file(in_file, True)
    print(gr)
    gr = gr.flatten().relabel_contiguous(offset)
    print(gr)
    gr.networkx_export(out_file)

    # requires file from OsmToRoadGraph repository
    # gr.draw("auckland.png")
    # gr_flat.adjacency_list()

export(1, "Maps/Auckland.pycgr")
